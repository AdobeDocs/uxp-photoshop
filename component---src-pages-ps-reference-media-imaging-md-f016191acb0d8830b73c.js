"use strict";(self.webpackChunkuxp_photoshop_documentation=self.webpackChunkuxp_photoshop_documentation||[]).push([[8532],{97162:function(e,a,t){t.r(a),t.d(a,{_frontmatter:function(){return m},default:function(){return s}});var n=t(87462),i=t(63366),l=(t(15007),t(64983)),r=t(91515),o=["components"],m={},d={_frontmatter:m},p=r.Z;function s(e){var a=e.components,t=(0,i.Z)(e,o);return(0,l.mdx)(p,(0,n.Z)({},d,t,{components:a,mdxType:"MDXLayout"}),(0,l.mdx)("h1",{id:"imaging-api-beta"},"Imaging API ",(0,l.mdx)("em",{parentName:"h1"},"Beta")),(0,l.mdx)("p",null,"The Imaging API ",(0,l.mdx)("em",{parentName:"p"},"Beta")," allows JavaScript to work directly with image data in Photoshop documents."),(0,l.mdx)("p",null,"These APIs are currently ",(0,l.mdx)("em",{parentName:"p"},"beta")," which means that they are not complete and may change in the future.  We present them here as a testing ground for this new capability.  Please send comments, questions or bugs via the Beta Feedback panel (under the Windows menu) or directly at the ",(0,l.mdx)("a",{parentName:"p",href:"https://community.adobe.com/t5/photoshop-beta/ct-p/ct-photoshop-beta"},"Beta forum"),"."),(0,l.mdx)("p",null,"The functionality has the following known issues:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"The API is only available in Photoshop (Beta) builds"),(0,l.mdx)("li",{parentName:"ul"},"Support is limited to RGB, gray scale, and Lab data"),(0,l.mdx)("li",{parentName:"ul"},"When using ",(0,l.mdx)("inlineCode",{parentName:"li"},"applyAlpha")," to matte the retrieved region's pixels on white, those pixels will still have had the empty pixels at the edges trimmed before the matte is applied.  Be sure to check the returned ",(0,l.mdx)("inlineCode",{parentName:"li"},"sourceBounds"),".")),(0,l.mdx)("p",null,"The Imaging API are exposed on the ",(0,l.mdx)("inlineCode",{parentName:"p"},"imaging_beta"),' sub-module under "photoshop". You can access these APIs by using the follow code:'),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},'const imaging = require("photoshop").imaging_beta;\n')),(0,l.mdx)("h2",{id:"terminology-and-data-types"},"Terminology and data types"),(0,l.mdx)("p",null,"Image data is expressed as a collection of ",(0,l.mdx)("inlineCode",{parentName:"p"},"pixels"),". A pixel represents all color information for a single point in the image. A pixel consists of one or more components of color values and alpha information."),(0,l.mdx)("p",null,'An RGB pixel with alpha information has four components: "red", "green", "blue", and "alpha". An opaque RGB pixel has only three components. Including an alpha channel as a fourth yields RGBA.\nAn opaque gray scale pixel has one component. A gray scale pixel with alpha has two components.'),(0,l.mdx)("p",null,"In order to properly interpret pixel data, Photoshop needs to know which color profile the data is expressed in. An example of a color profile is ",(0,l.mdx)("inlineCode",{parentName:"p"},'"Adobe RGB (1998)"'),". All image data here will include the associated profile, and Photoshop will perform color conversions when needed. You can get the list of available color profiles by invoking [","[Photoshop.getColorProfiles]","] on the app object:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},'const rgbProfiles = await require("photoshop").app.getColorProfiles("RGB");\n\nconst grayProfiles = await require("photoshop").app.getColorProfiles("Gray");\n')),(0,l.mdx)("p",null,"Photoshop supports two ways to store pixel information in memory:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"chunky"),": Components of a single pixels are stored consecutively in memory. If you have two opaque RGB pixels (pixel 1 and pixel 2), then they will be stored as: ",(0,l.mdx)("inlineCode",{parentName:"li"},"[R1, G1, B1, R2, G2, B2]"),"."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"planar"),": Similar components are stored consecutively in memory. Components for a single pixel may not appear consecutively in memory. If you have two opaque RGB pixels, then they will be stored as: ",(0,l.mdx)("inlineCode",{parentName:"li"},"[R1, R2, G1, G2, B1, B2]"),".")),(0,l.mdx)("p",null,"JavaScript APIs use the chunky format by default."),(0,l.mdx)("p",null,"Image data is represented by a ",(0,l.mdx)("inlineCode",{parentName:"p"},"PhotoshopImageData")," instance. This instance has the following methods and properties:"),(0,l.mdx)("h4",{id:"photoshopimagedata"},(0,l.mdx)("em",{parentName:"h4"},"PhotoshopImageData")),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Name"),(0,l.mdx)("th",{parentName:"tr",align:null},"Type"),(0,l.mdx)("th",{parentName:"tr",align:null},"Description"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"width"),(0,l.mdx)("td",{parentName:"tr",align:null},"Number"),(0,l.mdx)("td",{parentName:"tr",align:null},"The width of the image data in pixels.")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"height"),(0,l.mdx)("td",{parentName:"tr",align:null},"Number"),(0,l.mdx)("td",{parentName:"tr",align:null},"The height of the image data in pixels.")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"colorSpace"),(0,l.mdx)("td",{parentName:"tr",align:null},"String"),(0,l.mdx)("td",{parentName:"tr",align:null},"The color space (or mode) for the image data. This can be ",(0,l.mdx)("inlineCode",{parentName:"td"},'"RGB"'),", ",(0,l.mdx)("inlineCode",{parentName:"td"},'"Grayscale"'),", ",(0,l.mdx)("inlineCode",{parentName:"td"},'"Lab"'),".")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"colorProfile"),(0,l.mdx)("td",{parentName:"tr",align:null},"String"),(0,l.mdx)("td",{parentName:"tr",align:null},"The color profile for the image data. For example, ",(0,l.mdx)("inlineCode",{parentName:"td"},'"sRGB IEC61966-2.1"'),".")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"hasAlpha"),(0,l.mdx)("td",{parentName:"tr",align:null},"Boolean"),(0,l.mdx)("td",{parentName:"tr",align:null},"True if the image data includes an alpha channel. Only available with RGB.")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"components"),(0,l.mdx)("td",{parentName:"tr",align:null},"Number"),(0,l.mdx)("td",{parentName:"tr",align:null},"Number of components per pixel. This is 3 for RGB, 4 for RGBA and so forth.")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"componentSize"),(0,l.mdx)("td",{parentName:"tr",align:null},"Number"),(0,l.mdx)("td",{parentName:"tr",align:null},"Number of bits per component. This can be 8, 16, or 32.")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"pixelFormat"),(0,l.mdx)("td",{parentName:"tr",align:null},"String"),(0,l.mdx)("td",{parentName:"tr",align:null},"Memory layout (order) of components in a pixel. Could be ",(0,l.mdx)("inlineCode",{parentName:"td"},'"RGB"'),", ",(0,l.mdx)("inlineCode",{parentName:"td"},'"RGBA"'),", ",(0,l.mdx)("inlineCode",{parentName:"td"},'"Gray"'),", or ",(0,l.mdx)("inlineCode",{parentName:"td"},'"LAB"'),".")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"chunky"),(0,l.mdx)("td",{parentName:"tr",align:null},"Boolean"),(0,l.mdx)("td",{parentName:"tr",align:null},"True if the image data internally is using the chunky format.")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"type"),(0,l.mdx)("td",{parentName:"tr",align:null},"String"),(0,l.mdx)("td",{parentName:"tr",align:null},'Type of contained data. At the moment only "image/uncompressed" is supported.')),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"getData"),(0,l.mdx)("td",{parentName:"tr",align:null},"Method"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("a",{parentName:"td",href:"#getdata"},"See documentation below."))),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"dispose"),(0,l.mdx)("td",{parentName:"tr",align:null},"Method"),(0,l.mdx)("td",{parentName:"tr",align:null},(0,l.mdx)("a",{parentName:"td",href:"#dispose"},"See documentation below."))))),(0,l.mdx)("p",null,"When specifying bounds in the Imaging API, the resulting region will include the left and top locations up to the right and bottom locations. As an example: ",(0,l.mdx)("inlineCode",{parentName:"p"},"{left: 0, top: 0, right: 10, bottom: 10}")," will target ten pixels from location 0 to 9 in both directions (not including pixels from location 10). You can specify height and width instead of right and bottom - doing so can make the code easier to read: ",(0,l.mdx)("inlineCode",{parentName:"p"},"{left: 0, top: 0, width: 10, height: 10}"),"."),(0,l.mdx)("p",null,"The value range for pixel components depend on the componentSize."),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Component Size"),(0,l.mdx)("th",{parentName:"tr",align:null},"Value range"),(0,l.mdx)("th",{parentName:"tr",align:null},"Comments"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"8"),(0,l.mdx)("td",{parentName:"tr",align:null},"0..255"),(0,l.mdx)("td",{parentName:"tr",align:null})),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"16"),(0,l.mdx)("td",{parentName:"tr",align:null},"0..32768"),(0,l.mdx)("td",{parentName:"tr",align:null})),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"32"),(0,l.mdx)("td",{parentName:"tr",align:null},"0..1+"),(0,l.mdx)("td",{parentName:"tr",align:null},"High dynamic range images may have component values that are below 0 or above 1.0")))),(0,l.mdx)("p",null,"Instances of ",(0,l.mdx)("inlineCode",{parentName:"p"},"PhotoshopImageData")," cannot be created explicitly by JavaScript, but are returned from Imaging API methods."),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("a",{parentName:"li",href:"#getpixels"},"getPixels")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("a",{parentName:"li",href:"#getlayermask"},"getLayerMask")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("a",{parentName:"li",href:"#getselection"},"getSelection")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("a",{parentName:"li",href:"#createimagedatafrombuffer"},"createImageDataFromBuffer"))),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"performance-considerations"},"Performance considerations"),(0,l.mdx)("p",null,"Photoshop images can be (very) large. It is therefore important to manage the image data carefully in JavaScript.\nIf you use a large amount of JavaScript memory, then you may see warnings in the UDT debugger console such as the following:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre"},"Plugin memory usage increased to: 600MB.\nPlugin exceeds memory limit. Currently used memory 600.\n")),(0,l.mdx)("p",null,"The potential large data space has a number of implications."),(0,l.mdx)("p",null,"First off, all Imaging API methods that return pixels are asynchronous. This is needed because modifying and even querying pixel data may incur disk I/O."),(0,l.mdx)("p",null,"When requesting pixels, use the smallest possible target size. Specifying a small target size allows Photoshop to optimize the retrieval (and possibly document compositing) of the source region."),(0,l.mdx)("p",null,"When you are done working with image data, then you should call ",(0,l.mdx)("inlineCode",{parentName:"p"},"dispose")," on the ",(0,l.mdx)("inlineCode",{parentName:"p"},"PhotoshopImageData")," instance. This allow Photoshop to release memory immediately rather than waiting for garbage collection."),(0,l.mdx)("p",null,"Converting image data between different color spaces or color profiles is somewhat time consuming. Whenever possible, work with a color space and color profile that match the document that you are operating on."),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"apis"},"APIs"),(0,l.mdx)("h3",{id:"photoshopimagedata-1"},"PhotoshopImageData"),(0,l.mdx)("h4",{id:"getdata"},(0,l.mdx)("inlineCode",{parentName:"h4"},"getData")),(0,l.mdx)("p",null,"Return pixel information from an ",(0,l.mdx)("inlineCode",{parentName:"p"},"PhotoshopImageData")," instance as a typed array. The return type depends on the ",(0,l.mdx)("inlineCode",{parentName:"p"},"componentSize")," of the image."),(0,l.mdx)("table",null,(0,l.mdx)("thead",{parentName:"table"},(0,l.mdx)("tr",{parentName:"thead"},(0,l.mdx)("th",{parentName:"tr",align:null},"Component Size"),(0,l.mdx)("th",{parentName:"tr",align:null},"Return type"))),(0,l.mdx)("tbody",{parentName:"table"},(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"8"),(0,l.mdx)("td",{parentName:"tr",align:null},"Uint8Array")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"16"),(0,l.mdx)("td",{parentName:"tr",align:null},"Uint16Array")),(0,l.mdx)("tr",{parentName:"tbody"},(0,l.mdx)("td",{parentName:"tr",align:null},"32"),(0,l.mdx)("td",{parentName:"tr",align:null},"FloatArray")))),(0,l.mdx)("p",null,"The method takes an options argument. This argument can be used to specify attributes of the returned data. Possible options include:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"chunky")," | Boolean - Optional. If true then the data is returned as chunky data. If false, then data is returned in the planar format. The default value is true.")),(0,l.mdx)("p",null,"Return value: ",(0,l.mdx)("inlineCode",{parentName:"p"},"Promise<Uint8Array | Uint16Array | FloatArray>")),(0,l.mdx)("p",null,"The method is asynchronous, and thus returns a promise with the described data type."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},"const pixelData = await imageObj.imageData.getData()\n")),(0,l.mdx)("h4",{id:"dispose"},(0,l.mdx)("inlineCode",{parentName:"h4"},"dispose")),(0,l.mdx)("p",null,"Calling this synchronous method will release the contained image data. Doing so will reduce memory usage faster then waiting for the JavaScript garbage collector to run."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},"pixelData.dispose();\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h3",{id:"getpixels"},"getPixels"),(0,l.mdx)("p",null,"This API allows JavaScript to obtain pixel data from a Photoshop document. You can request pixels from an individual layer, or from the full document composite."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},"const imageObj = await imaging.getPixels(options);\n")),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"options | Object - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),"\nOptions describing the operation.",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"documentID")," | Number - Optional.  The id of the source document. If missing, or negative, then the source is the active document."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"layerID")," | Number - Optional.  The id of the source layer. If the value is not provided then the API returns pixels from the composite document image."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"sourceBounds")," | Object - Optional.  The region whose pixels should be returned. If the value is not provided, then pixels from the entire layer or document are is returned. The provided bounds will be trimmed to only that region that contains pixel data. In this event, the returned ",(0,l.mdx)("inlineCode",{parentName:"li"},"sourceBounds")," will reflect this smaller region. The provided object must describe a rectangle using one the following number-value property sets:",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"left"),", ",(0,l.mdx)("inlineCode",{parentName:"li"},"top"),", ",(0,l.mdx)("inlineCode",{parentName:"li"},"right"),", and ",(0,l.mdx)("inlineCode",{parentName:"li"},"bottom")),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"left"),", ",(0,l.mdx)("inlineCode",{parentName:"li"},"top"),", ",(0,l.mdx)("inlineCode",{parentName:"li"},"width"),", and ",(0,l.mdx)("inlineCode",{parentName:"li"},"height")))),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"targetSize")," | Object - Optional.  The dimensions of the returned image. If this value is not provided then the returned size will match the requested size. That is, no scaling will be performed on the returned pixels. The provided object must have one or more of the following attributes:",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"width")," and ",(0,l.mdx)("inlineCode",{parentName:"li"},"height"),". If only one dimension is included, then the returned image data is scaled proportionally to match the requested dimension."))),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"colorSpace")," | String - Optional. Requested color space of the returned pixels. If omitted, then the color space of the source document is used to convert colors."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"colorProfile")," | String - Optional. The name of a color profile to apply to the returned pixels. If omitted, then the resulting color profile depends on the requested color space:",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},"If the requested color space matches the source document, then the returned data will use the color profile of the source document."),(0,l.mdx)("li",{parentName:"ul"},"If the requested color space is different from the source document, then the working color profile for that color space is used to convert colors."))),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"componentSize")," | Number - Optional. The requested ",(0,l.mdx)("inlineCode",{parentName:"li"},"componentSize")," of the returned image data. If this property is omitted then the ",(0,l.mdx)("inlineCode",{parentName:"li"},"componentSize")," of the source pixel data is used. The value can be: -1 (for using the source document's depth), 8 , 16, or 32."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"applyAlpha")," | Boolean - Optional. If true, then RGBA pixels will be converted to RGB by matting on white."),(0,l.mdx)("li",{parentName:"ul"},"a possible alpha channel is applied to the pixels before returning. The returned imageData property will not contain an alpha channel.")))),(0,l.mdx)("p",null,"Return value: ",(0,l.mdx)("inlineCode",{parentName:"p"},"Promise<Object>")),(0,l.mdx)("p",null,"The returned object has the following properties:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"imageData")," | ",(0,l.mdx)("a",{parentName:"li",href:"#photoshopimagedata"},"PhotoshopImageData"),". A ",(0,l.mdx)("inlineCode",{parentName:"li"},"PhotoshopImageData")," instance describing the returned pixel data."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"sourceBounds")," | Object. The actual bounds used when obtaining pixels (see note regarding pyramid levels below)."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"level")," | Number. The pyramid level that was used when obtaining pixels.")),(0,l.mdx)("p",null,"Note: the ",(0,l.mdx)("inlineCode",{parentName:"p"},"components")," property of the image data depends on whether or not the pixel source includes an alpha channel, e.g., 4 for RGBA."),(0,l.mdx)("p",null,"If the targetSize is smaller than the requested region, then the resulting image data will be scaled down. When scaling, Photoshop may use a smaller (cached) version of the image canvas. This is known as a pyramid level. The number of pyramid levels that are available in a document is determined by the preference: ",(0,l.mdx)("em",{parentName:"p"},'"Performance Cache Levels"'),". Using a cache level may result in dramatic performance improvements. The returned level indicates which level that was used. Level 0 indicates the full resolution canvas. Level 1 indicates a cache that is half of the size of the full resolution, and so forth. The returned ",(0,l.mdx)("inlineCode",{parentName:"p"},"sourceBounds")," are relative to the bounds of the source cache level (not relative to the full resolution bounds)."),(0,l.mdx)("p",null,"The valid bounds for the ",(0,l.mdx)("inlineCode",{parentName:"p"},"sourceBounds")," depend on the pixel source. The origin of the composite image is ",(0,l.mdx)("inlineCode",{parentName:"p"},"(0, 0)"),",and the size is given by the properties ",(0,l.mdx)("inlineCode",{parentName:"p"},"width")," and ",(0,l.mdx)("inlineCode",{parentName:"p"},"height")," on the DOM object for the source document. The origin of a pixel layer can be different from ",(0,l.mdx)("inlineCode",{parentName:"p"},"(0, 0)"),". You can get the valid pixel bounds for a layer by calling ",(0,l.mdx)("inlineCode",{parentName:"p"},"boundsNoEffects")," on the DOM object corresponding to the source layer."),(0,l.mdx)("p",null,"Example - create a thumbnail of an region of the target document that is 100 pixels tall."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},"const thumbnail = await imaging.getPixels({\n    sourceBounds: { left: 0, top: 0, right: 300, bottom: 300 },\n    targetSize: { height: 100 }\n});\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h3",{id:"putpixels"},"putPixels"),(0,l.mdx)("p",null,"This API allows JavaScript to change pixel data in a layer. You can replace all pixels in a layer or a region of the layer."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},"await imaging.putPixels(options);\n")),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"options | Object - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),"\nOptions describing the operation.",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"documentID")," | Number - Optional.  The id of the source document. If missing, or negative, then the source is the active document."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"layerID")," | Number - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),".  The id of the target layer. The target layer must be a pixel layer."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"imageData")," | ",(0,l.mdx)("a",{parentName:"li",href:"#photoshopimagedata"},"PhotoshopImageData")," - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),". Value describing the pixel data."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"replace")," | Boolean - Optional. Describes how pixels are added to the layer. If true, then exising pixels in the layer are discarded before adding new pixels. If false, then the new pixels are added to the existing pixel content in the layer. The default value is true."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"targetBounds")," | Object - Optional.  The region where the pixels should be inserted. If the value is not provided, then pixels are inserted at the origin ",(0,l.mdx)("inlineCode",{parentName:"li"},"(0, 0)")," of the document. The provided object must include the following values: ",(0,l.mdx)("inlineCode",{parentName:"li"},"left"),", ",(0,l.mdx)("inlineCode",{parentName:"li"},"top"),". (Dimension keys ",(0,l.mdx)("inlineCode",{parentName:"li"},"width")," and ",(0,l.mdx)("inlineCode",{parentName:"li"},"height")," are not used.)"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"commandName")," | String - Optional. If provided then this name is used when creating an entry in the history panel.")))),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},"await imaging.putPixels({\n    layerID: 123\n    imageData: imageData\n});\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h3",{id:"getlayermask"},"getLayerMask"),(0,l.mdx)("p",null,"This API allows JavaScript to retrieve the pixel data representing a layer's mask."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},"const imageObj = await imaging.getLayerMask(options);\n")),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"options | Object - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),"\nOptions describing the operation.",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"documentID")," | Number - Optional.  The id of the source document. If the number is missing or negative, then the source will be the active document."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"layerID")," | Number - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),".  The id of the source layer."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"kind")," | String - Optional. The kind of mask to return. There are two options: ",(0,l.mdx)("inlineCode",{parentName:"li"},'"user"')," or ",(0,l.mdx)("inlineCode",{parentName:"li"},'"vector"'),". The default value is ",(0,l.mdx)("inlineCode",{parentName:"li"},'"user"'),' which is the kind (pixel) applied by "Add Layer Mask" button.'),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"sourceBounds")," | Object - Optional.  The region whose pixels should be returned. If the value is not provided, then pixels from the entire mask are returned. The provided object must describe a rectangle using the following number properties:",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"left"),", ",(0,l.mdx)("inlineCode",{parentName:"li"},"top"),", ",(0,l.mdx)("inlineCode",{parentName:"li"},"right"),", and ",(0,l.mdx)("inlineCode",{parentName:"li"},"bottom")))),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"targetSize")," | Object - Optional.  The dimensions of the returned image. If this value is not provided then the returned size will match the requested size (i.e. no scaling is performed on the returned pixels). The provided object must have one or more of the following attributes:",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"width")," and ",(0,l.mdx)("inlineCode",{parentName:"li"},"height"),". If only one dimension is provided then the returned image data is scaled proportionally to match the requested dimension.")))))),(0,l.mdx)("p",null,"Return value: ",(0,l.mdx)("inlineCode",{parentName:"p"},"Promise<Object>")),(0,l.mdx)("p",null,"The returned object has the following properties:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"imageData")," | ",(0,l.mdx)("a",{parentName:"li",href:"#photoshopimagedata"},"PhotoshopImageData"),". A ",(0,l.mdx)("inlineCode",{parentName:"li"},"PhotoshopImageData")," instance representing the pixels in the requested user mask. A user mask is represented as a single channel (gray scale image)."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"sourceBounds")," | Object. The actual bounds used when obtaining the mask pixels.")),(0,l.mdx)("p",null,"Example - get the user mask for a layer"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},'const imageObj = await imaging.getLayerMask({\n    documentID: 123,\n    layerID: 5,\n    kind: "user"\n    sourceBounds: { left: 0, top: 0, right: 300, bottom: 300 },\n    targetSize: { height: 100 }\n});\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h3",{id:"putlayermask"},"putLayerMask"),(0,l.mdx)("p",null,'This API allows JavaScript to edit the pixels of a layer\'s mask.  At this time, only pixel masks are editable. In the UI, they are what is referred to as a "Layer Mask".  '),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},"await imaging.putLayerMask(options);\n")),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"options | Object - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),"\nOptions describing the operation.",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"documentID")," | Number - Optional.  The id of the source document. If the number is missing or negative, then the source will be the active document."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"layerID")," | Number - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),".  The id of the target layer."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"kind")," | String - Optional. The kind of mask to change. Only ",(0,l.mdx)("inlineCode",{parentName:"li"},'"user"')," is accepted at this time. The default value is ",(0,l.mdx)("inlineCode",{parentName:"li"},'"user"'),"."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"imageData")," | ",(0,l.mdx)("a",{parentName:"li",href:"#photoshopimagedata"},"PhotoshopImageData")," - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),". Value describing the mask data. This must be image data with a single component using the grayscale color model."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"replace")," | Boolean - Optional. Describes how mask pixels are added. If true, then the exising mask in the layer is discarded before creating a new mask. If false, then the new image data is placed into to the existing mask in the layer. The default value is true."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"targetBounds")," | Object - Optional.  The region where the pixels should be inserted. If the value is not provided, then pixels are inserted at the origin ",(0,l.mdx)("inlineCode",{parentName:"li"},"(0, 0)"),". The provided object must include the following values: ",(0,l.mdx)("inlineCode",{parentName:"li"},"left"),", ",(0,l.mdx)("inlineCode",{parentName:"li"},"top"),". (Dimension keys ",(0,l.mdx)("inlineCode",{parentName:"li"},"width")," and ",(0,l.mdx)("inlineCode",{parentName:"li"},"height")," are not used here.)"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"commandName")," | String - Optional. If provided, then this name is used when creating an entry in the history panel.")))),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},"await imaging.putLayerMask({\n    layerID: 123\n    imageData: grayImageData\n});\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h3",{id:"getselection"},"getSelection"),(0,l.mdx)("p",null,"This API allows JavaScript to obtain a pixel representation of the active selection. Think of it like entering ",(0,l.mdx)("a",{parentName:"p",href:"https://helpx.adobe.com/photoshop/using/create-temporary-quick-mask.html"},"Quick Mask mode"),". "),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},"const imageObj = await imaging.getSelection(options);\n")),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"options | Object - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),"\nOptions describing the operation.",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"documentID")," | Number - Optional.  The id of the source document. If missing, or negative, then the source is the active document."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"sourceBounds")," | Object - Optional.  The region whose pixels should be returned. If the value is not provided, then pixels from the entire selection are returned. The provided object must describe a rectangle using the following number properties:",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"left"),", ",(0,l.mdx)("inlineCode",{parentName:"li"},"top"),", ",(0,l.mdx)("inlineCode",{parentName:"li"},"right"),", and ",(0,l.mdx)("inlineCode",{parentName:"li"},"bottom")))),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"targetSize")," | Object - Optional.  The dimensions of the returned image. If this value is not provided, then the returned size will match the requested size (i.e. no scaling is performed on the returned pixels). The provided object must have one or more of the following attributes:",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"width")," and ",(0,l.mdx)("inlineCode",{parentName:"li"},"height"),". If only one dimension is provided, then the returned image data is scaled proportionally to match the requested dimension.")))))),(0,l.mdx)("p",null,"Return value: ",(0,l.mdx)("inlineCode",{parentName:"p"},"Promise<Object>")),(0,l.mdx)("p",null,"The returned object has the following properties:"),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"imageData")," | ",(0,l.mdx)("a",{parentName:"li",href:"#photoshopimagedata"},"PhotoshopImageData"),". A ",(0,l.mdx)("inlineCode",{parentName:"li"},"PhotoshopImageData")," instance representing the selection."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"sourceBounds")," | Object. The actual bounds used when obtaining the selection pixels.")),(0,l.mdx)("p",null,"Example - get the document selection"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},"const imageObj = await imaging.getSelection({\n    documentID: 123,\n    sourceBounds: { left: 0, top: 0, right: 300, bottom: 300 }\n});\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h3",{id:"putselection"},"putSelection"),(0,l.mdx)("p",null,"This API allows JavaScript to change the selection itself using a provided pixel data representation.  Think of it like exiting ",(0,l.mdx)("a",{parentName:"p",href:"https://helpx.adobe.com/photoshop/using/create-temporary-quick-mask.html"},"Quick Mask mode"),"."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},"await imaging.putSelection(options);\n")),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"options | Object - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),"\nOptions describing the operation.",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"documentID")," | Number - Optional.  The id of the source document. If missing, or negative, then the source is the active document."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"replace")," | Boolean - Optional. Describes how selection is modified. If true, then the exising document selection is discarded before creating a new selection. If false, then the new image data is added to the existing document selection. The default value is true."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"targetBounds")," | Object - Optional.  The region where the selection should be inserted. If the value is not provided, then selection pixels are inserted at the origin ",(0,l.mdx)("inlineCode",{parentName:"li"},"(0, 0)"),". The provided object must include the following values: ",(0,l.mdx)("inlineCode",{parentName:"li"},"left"),", ",(0,l.mdx)("inlineCode",{parentName:"li"},"top"),". (Dimension keys ",(0,l.mdx)("inlineCode",{parentName:"li"},"width")," and ",(0,l.mdx)("inlineCode",{parentName:"li"},"height")," are not used here.)"),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"commandName")," | String - Optional. If provided, then this name is used when creating an entry in the history panel.")))),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},"await imaging.putSelection({ imageData: grayImageData });\n")),(0,l.mdx)("hr",null),(0,l.mdx)("h3",{id:"createimagedatafrombuffer"},"createImageDataFromBuffer"),(0,l.mdx)("p",null,"This API allows JavaScript to create arbitrary image data from a memory buffer."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},"const imageData = await imaging.createImageDataFromBuffer(arrayBuffer, options);\n")),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"imageData")," | Typed array - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required"))," | Desc ribes the image data. Accepted types are: ",(0,l.mdx)("inlineCode",{parentName:"li"},"Uint8Array"),", ",(0,l.mdx)("inlineCode",{parentName:"li"},"Uint16Array"),", and ",(0,l.mdx)("inlineCode",{parentName:"li"},"FloatArray"),". The used type will indicate the componentSize of the provided data. See table above."),(0,l.mdx)("li",{parentName:"ul"},"options | Object - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),"\nOptions describing the operation.",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"width")," | Number - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),". The width of the image."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"height")," | Number - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),". The height of the image."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"components")," | Number - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),". Number of components per pixel."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"chunky")," | Boolean - Optional. Describes pixel layout. See discussion above. The default value is true."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"colorProfile")," | String - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),". Describes the color profile associated with the image data."),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("inlineCode",{parentName:"li"},"colorSpace")," | String - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),". Describes the color space associated with the image data. Can be ",(0,l.mdx)("inlineCode",{parentName:"li"},'"RGB"')," or ",(0,l.mdx)("inlineCode",{parentName:"li"},'"Grayscale"'))))),(0,l.mdx)("p",null,"Return value: ",(0,l.mdx)("inlineCode",{parentName:"p"},"Promise<PhotoshopImageData>")),(0,l.mdx)("p",null,"The number of elements in imageData must be equal to: ",(0,l.mdx)("inlineCode",{parentName:"p"},"width * height * components"),"."),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},'const width = 30;\nconst height = 40;\nconst components = 4;  // RGBA\nconst componentCount = width * height;\nconst dataSize = componentCount * components;\nconst arrayBuffer = new Uint8Array(dataSize);\n\n// Add some (chunky) data to the buffer\nfor (let i = 0 ; i < componentCount; i += components) {\n    arrayBuffer[index]   = 255;      // red\n    arrayBuffer[index+1] = 0;        // green\n    arrayBuffer[index+2] = 0;        // blue\n    arrayBuffer[index+3] = 127;      // alpha\n}\n\nconst options = {\n   width: width,\n   height: height,\n   components: components,\n   colorProfile: "sRGB IEC61966-2.1",\n   colorSpace: "RGB"\n};\nconst imageData = await imaging.createImageDataFromBuffer(arrayBuffer, options)\n')),(0,l.mdx)("p",null,"Image data that is used for layer masks or document selections uses a single grayscale component. When creating such data, use ",(0,l.mdx)("inlineCode",{parentName:"p"},"components: 1"),", ",(0,l.mdx)("inlineCode",{parentName:"p"},'colorSpace: "Grayscale"')," and ",(0,l.mdx)("inlineCode",{parentName:"p"},'colorProfile: "Generic Gray Profile"')," as shown in the following example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},'const width = 30;\nconst height = 40;\nconst componentCount = width * height;\nconst arrayBuffer = new Uint8Array(componentCount);\n\nfor (let i = 0 ; i < componentCount; ++i) {\n   arrayBuffer[i] = 127; // all set to the median value\n}\n\nconst options = {\n   width: width,\n   height: height,\n   components: 1,  // masks are grayscale\n   chunky: false,\n   colorProfile: "Generic Gray Profile",\n   colorSpace: "Grayscale"\n};\nconst maskData = await imaging.createImageDataFromBuffer(arrayBuffer, options)\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h3",{id:"encodeimagedata"},"encodeImageData"),(0,l.mdx)("p",null,"This API is exposed to allow image data to be used with UXP image elements. With the current version of UXP you must use jpeg/base64 encoding when assigning to an image element."),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},"const dataImage = await imaging.encodeImageData(options);\n")),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},"options | Object - Required\nOptions describing the operation.",(0,l.mdx)("ul",{parentName:"li"},(0,l.mdx)("li",{parentName:"ul"},"imageData | ",(0,l.mdx)("a",{parentName:"li",href:"#photoshopimagedata"},"PhotoshopImageData")," - ",(0,l.mdx)("strong",{parentName:"li"},(0,l.mdx)("em",{parentName:"strong"},"Required")),". Value describing the pixel data."),(0,l.mdx)("li",{parentName:"ul"},"base64 | Boolean - Optional. If provided, then the returned value will be a string that is base64 encoded.")))),(0,l.mdx)("p",null,"Return value: ",(0,l.mdx)("inlineCode",{parentName:"p"},"Promise<Number[] | string>")),(0,l.mdx)("p",null,"Example:"),(0,l.mdx)("pre",null,(0,l.mdx)("code",{parentName:"pre",className:"language-javascript"},'const imageElement = document.createElement(\'img\');\n\nconst jpegData = await imaging.encodeImageData({"imageData": imgObj.imageData, "base64": true});\n\nconst dataUrl = "data:image/jpeg;base64," + jpegData;\nimageElement.src = dataUrl;\ndocument.body.appendChild(imageElement);\n')),(0,l.mdx)("hr",null),(0,l.mdx)("h2",{id:"sample-files"},"Sample files"),(0,l.mdx)("p",null,"Here you will find a sample plugin (",(0,l.mdx)("a",{parentName:"p",href:"../../../guides/devtool/plugin-management/#adding-an-existing-plugin"},"how to load"),") and ",(0,l.mdx)("a",{parentName:"p",href:"uxpscripting.md"},"UXP JavaScript file")," (.psjs) that exercise most of the above."),(0,l.mdx)("ul",null,(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("h3",{parentName:"li",id:"uxp-plugin---imaging-test"},"UXP plugin - ",(0,l.mdx)("a",{parentName:"h3",href:"/uxp-photoshop/assets/e53b6473e5d4a70fd0c43e2d8793855b/imaging-test.zip"},"imaging-test"))),(0,l.mdx)("li",{parentName:"ul"},(0,l.mdx)("h3",{parentName:"li",id:"uxp-script---imagingjs"},"UXP script - ",(0,l.mdx)("a",{parentName:"h3",href:"/uxp-photoshop/assets/874d23d0b54117a6e72ee98bbe79c41b/imaging.psjs"},"imaging.js")))))}s.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-ps-reference-media-imaging-md-f016191acb0d8830b73c.js.map