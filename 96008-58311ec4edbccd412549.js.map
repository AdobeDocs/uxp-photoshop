{"version":3,"file":"96008-58311ec4edbccd412549.js","mappings":"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","sources":["webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/enums.js","webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/parent/getOriginFromSrc.js","webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/errorSerialization.js","webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/generateId.js","webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/methodSerialization.js","webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/connectCallSender.js","webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/parent/handleAckMessageFactory.js","webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/connectCallReceiver.js","webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/parent/monitorIframeRemoval.js","webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/parent/connectToChild.js","webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/createLogger.js","webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/createDestructor.js","webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/parent/validateIframeHasSrcOrSrcDoc.js","webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/parent/handleSynMessageFactory.js","webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/startConnectionTimeout.js","webpack://uxp-photoshop-documentation/./node_modules/penpal/lib/child/connectToParent.js","webpack://uxp-photoshop-documentation/./node_modules/@adobe/gatsby-theme-aio/src/components/Frame/index.js"],"sourcesContent":["export var MessageType;\n(function (MessageType) {\n  MessageType[\"Call\"] = \"call\";\n  MessageType[\"Reply\"] = \"reply\";\n  MessageType[\"Syn\"] = \"syn\";\n  MessageType[\"SynAck\"] = \"synAck\";\n  MessageType[\"Ack\"] = \"ack\";\n})(MessageType || (MessageType = {}));\nexport var Resolution;\n(function (Resolution) {\n  Resolution[\"Fulfilled\"] = \"fulfilled\";\n  Resolution[\"Rejected\"] = \"rejected\";\n})(Resolution || (Resolution = {}));\nexport var ErrorCode;\n(function (ErrorCode) {\n  ErrorCode[\"ConnectionDestroyed\"] = \"ConnectionDestroyed\";\n  ErrorCode[\"ConnectionTimeout\"] = \"ConnectionTimeout\";\n  ErrorCode[\"NoIframeSrc\"] = \"NoIframeSrc\";\n})(ErrorCode || (ErrorCode = {}));\nexport var NativeErrorName;\n(function (NativeErrorName) {\n  NativeErrorName[\"DataCloneError\"] = \"DataCloneError\";\n})(NativeErrorName || (NativeErrorName = {}));\nexport var NativeEventType;\n(function (NativeEventType) {\n  NativeEventType[\"Message\"] = \"message\";\n})(NativeEventType || (NativeEventType = {}));","const DEFAULT_PORT_BY_PROTOCOL = {\n  'http:': '80',\n  'https:': '443'\n};\nconst URL_REGEX = /^(https?:)?\\/\\/([^/:]+)?(:(\\d+))?/;\nconst opaqueOriginSchemes = ['file:', 'data:'];\n/**\n * Converts a src value into an origin.\n */\nexport default (src => {\n  if (src && opaqueOriginSchemes.find(scheme => src.startsWith(scheme))) {\n    // The origin of the child document is an opaque origin and its\n    // serialization is \"null\"\n    // https://html.spec.whatwg.org/multipage/origin.html#origin\n    return 'null';\n  }\n  // Note that if src is undefined, then srcdoc is being used instead of src\n  // and we can follow this same logic below to get the origin of the parent,\n  // which is the origin that we will need to use.\n  const location = document.location;\n  const regexResult = URL_REGEX.exec(src);\n  let protocol;\n  let hostname;\n  let port;\n  if (regexResult) {\n    // It's an absolute URL. Use the parsed info.\n    // regexResult[1] will be undefined if the URL starts with //\n    protocol = regexResult[1] ? regexResult[1] : location.protocol;\n    hostname = regexResult[2];\n    port = regexResult[4];\n  } else {\n    // It's a relative path. Use the current location's info.\n    protocol = location.protocol;\n    hostname = location.hostname;\n    port = location.port;\n  }\n  // If the port is the default for the protocol, we don't want to add it to the origin string\n  // or it won't match the message's event.origin.\n  const portSuffix = port && port !== DEFAULT_PORT_BY_PROTOCOL[protocol] ? \":\".concat(port) : '';\n  return \"\".concat(protocol, \"//\").concat(hostname).concat(portSuffix);\n});","/**\n * Converts an error object into a plain object.\n */\nexport const serializeError = _ref => {\n  let {\n    name,\n    message,\n    stack\n  } = _ref;\n  return {\n    name,\n    message,\n    stack\n  };\n};\n/**\n * Converts a plain object into an error object.\n */\nexport const deserializeError = obj => {\n  const deserializedError = new Error();\n  // @ts-ignore\n  Object.keys(obj).forEach(key => deserializedError[key] = obj[key]);\n  return deserializedError;\n};","let id = 0;\n/**\n * @return {number} A unique ID (not universally unique)\n */\nexport default (() => ++id);","const KEY_PATH_DELIMITER = '.';\nconst keyPathToSegments = keyPath => keyPath ? keyPath.split(KEY_PATH_DELIMITER) : [];\nconst segmentsToKeyPath = segments => segments.join(KEY_PATH_DELIMITER);\nconst createKeyPath = (key, prefix) => {\n  const segments = keyPathToSegments(prefix || '');\n  segments.push(key);\n  return segmentsToKeyPath(segments);\n};\n/**\n * Given a `keyPath`, set it to be `value` on `subject`, creating any intermediate\n * objects along the way.\n *\n * @param {Object} subject The object on which to set value.\n * @param {string} keyPath The key path at which to set value.\n * @param {Object} value The value to store at the given key path.\n * @returns {Object} Updated subject.\n */\nexport const setAtKeyPath = (subject, keyPath, value) => {\n  const segments = keyPathToSegments(keyPath);\n  segments.reduce((prevSubject, key, idx) => {\n    if (typeof prevSubject[key] === 'undefined') {\n      prevSubject[key] = {};\n    }\n    if (idx === segments.length - 1) {\n      prevSubject[key] = value;\n    }\n    return prevSubject[key];\n  }, subject);\n  return subject;\n};\n/**\n * Given a dictionary of (nested) keys to function, flatten them to a map\n * from key path to function.\n *\n * @param {Object} methods The (potentially nested) object to serialize.\n * @param {string} prefix A string with which to prefix entries. Typically not intended to be used by consumers.\n * @returns {Object} An map from key path in `methods` to functions.\n */\nexport const serializeMethods = (methods, prefix) => {\n  const flattenedMethods = {};\n  Object.keys(methods).forEach(key => {\n    const value = methods[key];\n    const keyPath = createKeyPath(key, prefix);\n    if (typeof value === 'object') {\n      // Recurse into any nested children.\n      Object.assign(flattenedMethods, serializeMethods(value, keyPath));\n    }\n    if (typeof value === 'function') {\n      // If we've found a method, expose it.\n      flattenedMethods[keyPath] = value;\n    }\n  });\n  return flattenedMethods;\n};\n/**\n * Given a map of key paths to functions, unpack the key paths to an object.\n *\n * @param {Object} flattenedMethods A map of key paths to functions to unpack.\n * @returns {Object} A (potentially nested) map of functions.\n */\nexport const deserializeMethods = flattenedMethods => {\n  const methods = {};\n  for (const keyPath in flattenedMethods) {\n    setAtKeyPath(methods, keyPath, flattenedMethods[keyPath]);\n  }\n  return methods;\n};","import generateId from './generateId';\nimport { deserializeError } from './errorSerialization';\nimport { deserializeMethods } from './methodSerialization';\nimport { ErrorCode, MessageType, NativeEventType, Resolution } from './enums';\n/**\n * Augments an object with methods that match those defined by the remote. When these methods are\n * called, a \"call\" message will be sent to the remote, the remote's corresponding method will be\n * executed, and the method's return value will be returned via a message.\n * @param {Object} callSender Sender object that should be augmented with methods.\n * @param {Object} info Information about the local and remote windows.\n * @param {Array} methodKeyPaths Key paths of methods available to be called on the remote.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Object} The call sender object with methods that may be called.\n */\nexport default ((callSender, info, methodKeyPaths, destroyConnection, log) => {\n  const {\n    localName,\n    local,\n    remote,\n    originForSending,\n    originForReceiving\n  } = info;\n  let destroyed = false;\n  log(\"\".concat(localName, \": Connecting call sender\"));\n  const createMethodProxy = methodName => {\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      log(\"\".concat(localName, \": Sending \").concat(methodName, \"() call\"));\n      // This handles the case where the iframe has been removed from the DOM\n      // (and therefore its window closed), the consumer has not yet\n      // called destroy(), and the user calls a method exposed by\n      // the remote. We detect the iframe has been removed and force\n      // a destroy() immediately so that the consumer sees the error saying\n      // the connection has been destroyed. We wrap this check in a try catch\n      // because Edge throws an \"Object expected\" error when accessing\n      // contentWindow.closed on a contentWindow from an iframe that's been\n      // removed from the DOM.\n      let iframeRemoved;\n      try {\n        if (remote.closed) {\n          iframeRemoved = true;\n        }\n      } catch (e) {\n        iframeRemoved = true;\n      }\n      if (iframeRemoved) {\n        destroyConnection();\n      }\n      if (destroyed) {\n        const error = new Error(\"Unable to send \".concat(methodName, \"() call due \") + \"to destroyed connection\");\n        error.code = ErrorCode.ConnectionDestroyed;\n        throw error;\n      }\n      return new Promise((resolve, reject) => {\n        const id = generateId();\n        const handleMessageEvent = event => {\n          if (event.source !== remote || event.data.penpal !== MessageType.Reply || event.data.id !== id) {\n            return;\n          }\n          if (originForReceiving !== '*' && event.origin !== originForReceiving) {\n            log(\"\".concat(localName, \" received message from origin \").concat(event.origin, \" which did not match expected origin \").concat(originForReceiving));\n            return;\n          }\n          const replyMessage = event.data;\n          log(\"\".concat(localName, \": Received \").concat(methodName, \"() reply\"));\n          local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n          let returnValue = replyMessage.returnValue;\n          if (replyMessage.returnValueIsError) {\n            returnValue = deserializeError(returnValue);\n          }\n          (replyMessage.resolution === Resolution.Fulfilled ? resolve : reject)(returnValue);\n        };\n        local.addEventListener(NativeEventType.Message, handleMessageEvent);\n        const callMessage = {\n          penpal: MessageType.Call,\n          id,\n          methodName,\n          args\n        };\n        remote.postMessage(callMessage, originForSending);\n      });\n    };\n  };\n  // Wrap each method in a proxy which sends it to the corresponding receiver.\n  const flattenedMethods = methodKeyPaths.reduce((api, name) => {\n    api[name] = createMethodProxy(name);\n    return api;\n  }, {});\n  // Unpack the structure of the provided methods object onto the CallSender, exposing\n  // the methods in the same shape they were provided.\n  Object.assign(callSender, deserializeMethods(flattenedMethods));\n  return () => {\n    destroyed = true;\n  };\n});","import connectCallReceiver from '../connectCallReceiver';\nimport connectCallSender from '../connectCallSender';\n/**\n * Handles an ACK handshake message.\n */\nexport default ((serializedMethods, childOrigin, originForSending, destructor, log) => {\n  const {\n    destroy,\n    onDestroy\n  } = destructor;\n  let destroyCallReceiver;\n  let receiverMethodNames;\n  // We resolve the promise with the call sender. If the child reconnects\n  // (for example, after refreshing or navigating to another page that\n  // uses Penpal, we'll update the call sender with methods that match the\n  // latest provided by the child.\n  const callSender = {};\n  return event => {\n    if (childOrigin !== '*' && event.origin !== childOrigin) {\n      log(\"Parent: Handshake - Received ACK message from origin \".concat(event.origin, \" which did not match expected origin \").concat(childOrigin));\n      return;\n    }\n    log('Parent: Handshake - Received ACK');\n    const info = {\n      localName: 'Parent',\n      local: window,\n      remote: event.source,\n      originForSending: originForSending,\n      originForReceiving: childOrigin\n    };\n    // If the child reconnected, we need to destroy the prior call receiver\n    // before setting up a new one.\n    if (destroyCallReceiver) {\n      destroyCallReceiver();\n    }\n    destroyCallReceiver = connectCallReceiver(info, serializedMethods, log);\n    onDestroy(destroyCallReceiver);\n    // If the child reconnected, we need to remove the methods from the\n    // previous call receiver off the sender.\n    if (receiverMethodNames) {\n      receiverMethodNames.forEach(receiverMethodName => {\n        delete callSender[receiverMethodName];\n      });\n    }\n    receiverMethodNames = event.data.methodNames;\n    const destroyCallSender = connectCallSender(callSender, info, receiverMethodNames, destroy, log);\n    onDestroy(destroyCallSender);\n    return callSender;\n  };\n});","import { serializeError } from './errorSerialization';\nimport { MessageType, NativeEventType, NativeErrorName, Resolution } from './enums';\n/**\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\n * responds with the return value.\n */\nexport default ((info, serializedMethods, log) => {\n  const {\n    localName,\n    local,\n    remote,\n    originForSending,\n    originForReceiving\n  } = info;\n  let destroyed = false;\n  const handleMessageEvent = event => {\n    if (event.source !== remote || event.data.penpal !== MessageType.Call) {\n      return;\n    }\n    if (originForReceiving !== '*' && event.origin !== originForReceiving) {\n      log(\"\".concat(localName, \" received message from origin \").concat(event.origin, \" which did not match expected origin \").concat(originForReceiving));\n      return;\n    }\n    const callMessage = event.data;\n    const {\n      methodName,\n      args,\n      id\n    } = callMessage;\n    log(\"\".concat(localName, \": Received \").concat(methodName, \"() call\"));\n    const createPromiseHandler = resolution => {\n      return returnValue => {\n        log(\"\".concat(localName, \": Sending \").concat(methodName, \"() reply\"));\n        if (destroyed) {\n          // It's possible to throw an error here, but it would need to be thrown asynchronously\n          // and would only be catchable using window.onerror. This is because the consumer\n          // is merely returning a value from their method and not calling any function\n          // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n          // the value of doing so is questionable. Instead, we'll just log a message.\n          log(\"\".concat(localName, \": Unable to send \").concat(methodName, \"() reply due to destroyed connection\"));\n          return;\n        }\n        const message = {\n          penpal: MessageType.Reply,\n          id,\n          resolution,\n          returnValue\n        };\n        if (resolution === Resolution.Rejected && returnValue instanceof Error) {\n          message.returnValue = serializeError(returnValue);\n          message.returnValueIsError = true;\n        }\n        try {\n          remote.postMessage(message, originForSending);\n        } catch (err) {\n          // If a consumer attempts to send an object that's not cloneable (e.g., window),\n          // we want to ensure the receiver's promise gets rejected.\n          if (err.name === NativeErrorName.DataCloneError) {\n            const errorReplyMessage = {\n              penpal: MessageType.Reply,\n              id,\n              resolution: Resolution.Rejected,\n              returnValue: serializeError(err),\n              returnValueIsError: true\n            };\n            remote.postMessage(errorReplyMessage, originForSending);\n          }\n          throw err;\n        }\n      };\n    };\n    new Promise(resolve => resolve(serializedMethods[methodName].apply(serializedMethods, args))).then(createPromiseHandler(Resolution.Fulfilled), createPromiseHandler(Resolution.Rejected));\n  };\n  local.addEventListener(NativeEventType.Message, handleMessageEvent);\n  return () => {\n    destroyed = true;\n    local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n  };\n});","const CHECK_IFRAME_IN_DOC_INTERVAL = 60000;\n/**\n * Monitors for iframe removal and destroys connection if iframe\n * is found to have been removed from DOM. This is to prevent memory\n * leaks when the iframe is removed from the document and the consumer\n * hasn't called destroy(). Without this, event listeners attached to\n * the window would stick around and since the event handlers have a\n * reference to the iframe in their closures, the iframe would stick\n * around too.\n */\nexport default ((iframe, destructor) => {\n  const {\n    destroy,\n    onDestroy\n  } = destructor;\n  const checkIframeInDocIntervalId = setInterval(() => {\n    if (!iframe.isConnected) {\n      clearInterval(checkIframeInDocIntervalId);\n      destroy();\n    }\n  }, CHECK_IFRAME_IN_DOC_INTERVAL);\n  onDestroy(() => {\n    clearInterval(checkIframeInDocIntervalId);\n  });\n});","import { MessageType, NativeEventType } from '../enums';\nimport createDestructor from '../createDestructor';\nimport createLogger from '../createLogger';\nimport getOriginFromSrc from './getOriginFromSrc';\nimport handleAckMessageFactory from './handleAckMessageFactory';\nimport handleSynMessageFactory from './handleSynMessageFactory';\nimport { serializeMethods } from '../methodSerialization';\nimport monitorIframeRemoval from './monitorIframeRemoval';\nimport startConnectionTimeout from '../startConnectionTimeout';\nimport validateIframeHasSrcOrSrcDoc from './validateIframeHasSrcOrSrcDoc';\n/**\n * Attempts to establish communication with an iframe.\n */\nexport default (options => {\n  let {\n    iframe,\n    methods = {},\n    childOrigin,\n    timeout,\n    debug = false\n  } = options;\n  const log = createLogger(debug);\n  const destructor = createDestructor('Parent', log);\n  const {\n    onDestroy,\n    destroy\n  } = destructor;\n  if (!childOrigin) {\n    validateIframeHasSrcOrSrcDoc(iframe);\n    childOrigin = getOriginFromSrc(iframe.src);\n  }\n  // If event.origin is \"null\", the remote protocol is file: or data: and we\n  // must post messages with \"*\" as targetOrigin when sending messages.\n  // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Using_window.postMessage_in_extensions\n  const originForSending = childOrigin === 'null' ? '*' : childOrigin;\n  const serializedMethods = serializeMethods(methods);\n  const handleSynMessage = handleSynMessageFactory(log, serializedMethods, childOrigin, originForSending);\n  const handleAckMessage = handleAckMessageFactory(serializedMethods, childOrigin, originForSending, destructor, log);\n  const promise = new Promise((resolve, reject) => {\n    const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);\n    const handleMessage = event => {\n      if (event.source !== iframe.contentWindow || !event.data) {\n        return;\n      }\n      if (event.data.penpal === MessageType.Syn) {\n        handleSynMessage(event);\n        return;\n      }\n      if (event.data.penpal === MessageType.Ack) {\n        const callSender = handleAckMessage(event);\n        if (callSender) {\n          stopConnectionTimeout();\n          resolve(callSender);\n        }\n        return;\n      }\n    };\n    window.addEventListener(NativeEventType.Message, handleMessage);\n    log('Parent: Awaiting handshake');\n    monitorIframeRemoval(iframe, destructor);\n    onDestroy(error => {\n      window.removeEventListener(NativeEventType.Message, handleMessage);\n      if (error) {\n        reject(error);\n      }\n    });\n  });\n  return {\n    promise,\n    destroy() {\n      // Don't allow consumer to pass an error into destroy.\n      destroy();\n    }\n  };\n});","export default (debug => {\n  /**\n   * Logs a message if debug is enabled.\n   */\n  return function () {\n    if (debug) {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      console.log('[Penpal]', ...args); // eslint-disable-line no-console\n    }\n  };\n});","export default ((localName, log) => {\n  const callbacks = [];\n  let destroyed = false;\n  return {\n    destroy(error) {\n      if (!destroyed) {\n        destroyed = true;\n        log(\"\".concat(localName, \": Destroying connection\"));\n        callbacks.forEach(callback => {\n          callback(error);\n        });\n      }\n    },\n    onDestroy(callback) {\n      destroyed ? callback() : callbacks.push(callback);\n    }\n  };\n});","import { ErrorCode } from '../enums';\nexport default (iframe => {\n  if (!iframe.src && !iframe.srcdoc) {\n    const error = new Error('Iframe must have src or srcdoc property defined.');\n    error.code = ErrorCode.NoIframeSrc;\n    throw error;\n  }\n});","import { MessageType } from '../enums';\n/**\n * Handles a SYN handshake message.\n */\nexport default ((log, serializedMethods, childOrigin, originForSending) => {\n  return event => {\n    // Under specific timing circumstances, we can receive an event\n    // whose source is null. This seems to happen when the child iframe is\n    // removed from the DOM about the same time it has sent the SYN event.\n    // https://github.com/Aaronius/penpal/issues/85\n    if (!event.source) {\n      return;\n    }\n    if (childOrigin !== '*' && event.origin !== childOrigin) {\n      log(\"Parent: Handshake - Received SYN message from origin \".concat(event.origin, \" which did not match expected origin \").concat(childOrigin));\n      return;\n    }\n    log('Parent: Handshake - Received SYN, responding with SYN-ACK');\n    const synAckMessage = {\n      penpal: MessageType.SynAck,\n      methodNames: Object.keys(serializedMethods)\n    };\n    event.source.postMessage(synAckMessage, originForSending);\n  };\n});","import { ErrorCode } from './enums';\n/**\n * Starts a timeout and calls the callback with an error\n * if the timeout completes before the stop function is called.\n */\nexport default ((timeout, callback) => {\n  let timeoutId;\n  if (timeout !== undefined) {\n    timeoutId = window.setTimeout(() => {\n      const error = new Error(\"Connection timed out after \".concat(timeout, \"ms\"));\n      error.code = ErrorCode.ConnectionTimeout;\n      callback(error);\n    }, timeout);\n  }\n  return () => {\n    clearTimeout(timeoutId);\n  };\n});","import createDestructor from '../createDestructor';\nimport createLogger from '../createLogger';\nimport { MessageType, NativeEventType } from '../enums';\nimport handleSynAckMessageFactory from './handleSynAckMessageFactory';\nimport { serializeMethods } from '../methodSerialization';\nimport startConnectionTimeout from '../startConnectionTimeout';\nconst areGlobalsAccessible = () => {\n  try {\n    clearTimeout();\n  } catch (e) {\n    return false;\n  }\n  return true;\n};\n/**\n * Attempts to establish communication with the parent window.\n */\nexport default (function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    parentOrigin = '*',\n    methods = {},\n    timeout,\n    debug = false\n  } = options;\n  const log = createLogger(debug);\n  const destructor = createDestructor('Child', log);\n  const {\n    destroy,\n    onDestroy\n  } = destructor;\n  const serializedMethods = serializeMethods(methods);\n  const handleSynAckMessage = handleSynAckMessageFactory(parentOrigin, serializedMethods, destructor, log);\n  const sendSynMessage = () => {\n    log('Child: Handshake - Sending SYN');\n    const synMessage = {\n      penpal: MessageType.Syn\n    };\n    const parentOriginForSyn = parentOrigin instanceof RegExp ? '*' : parentOrigin;\n    window.parent.postMessage(synMessage, parentOriginForSyn);\n  };\n  const promise = new Promise((resolve, reject) => {\n    const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);\n    const handleMessage = event => {\n      // Under niche scenarios, we get into this function after\n      // the iframe has been removed from the DOM. In Edge, this\n      // results in \"Object expected\" errors being thrown when we\n      // try to access properties on window (global properties).\n      // For this reason, we try to access a global up front (clearTimeout)\n      // and if it fails we can assume the iframe has been removed\n      // and we ignore the message event.\n      if (!areGlobalsAccessible()) {\n        return;\n      }\n      if (event.source !== parent || !event.data) {\n        return;\n      }\n      if (event.data.penpal === MessageType.SynAck) {\n        const callSender = handleSynAckMessage(event);\n        if (callSender) {\n          window.removeEventListener(NativeEventType.Message, handleMessage);\n          stopConnectionTimeout();\n          resolve(callSender);\n        }\n      }\n    };\n    window.addEventListener(NativeEventType.Message, handleMessage);\n    sendSynMessage();\n    onDestroy(error => {\n      window.removeEventListener(NativeEventType.Message, handleMessage);\n      if (error) {\n        reject(error);\n      }\n    });\n  });\n  return {\n    promise,\n    destroy() {\n      // Don't allow consumer to pass an error into destroy.\n      destroy();\n    }\n  };\n});","/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport React, { useContext, useRef, useEffect, useState } from 'react';\nimport { withPrefix } from 'gatsby';\nimport { css } from '@emotion/react';\nimport { connectToChild } from 'penpal';\nimport { Footer } from '../Footer';\nimport PropTypes from 'prop-types';\nimport Context from '../Context';\nimport { isExternalLink } from '../../utils';\n\nconst Frame = ({ src, height = 'calc(100vh - var(--spectrum-global-dimension-size-800))', location }) => {\n  const iframe = useRef(null);\n  // some strangeness with ims not being set within context???\n  const { ims, isLoadingIms } = useContext(Context);\n  let imsHack;\n  const [child, setChild] = useState(null);\n\n  // ensures connectToChild is called before the child calls connectToParent\n  const [connectionReady, setConnectionReady] = useState(false);\n\n  useEffect(() => {\n    if (child) {\n      if (iframe.current.clientHeight === 0) {\n        child.onHide();\n      } else {\n        child.onShow();\n      }\n    }\n  }, [location.pathname]);\n\n  useEffect(() => {\n    setConnectionReady(false);\n    if (iframe != null && !isLoadingIms) {\n\n      // TODO: figure out why ims from context is not being updated so have to use a hacky solution like this\n      imsHack = window.adobeIMS;\n      const connection = createConnection();\n\n      return () => {\n        connection.destroy();\n      };\n    }\n  }, [iframe, isLoadingIms]);\n\n  const iframeSrc = isExternalLink(src) ? src : withPrefix(src);\n\n  const createConnection = () => {\n    const connection = connectToChild({\n      // The iframe to which a connection should be made\n      iframe: iframe.current,\n      // Manually set origin as auto-detection may fail, as the src of the iframe is set later\n      childOrigin: isExternalLink(src) ? new URL(src).origin : window.origin,\n      // Methods the parent is exposing to the child\n      methods: {\n        scrollTop(position = 0) {\n          if (document?.scrollingElement) {\n            document.scrollingElement.scrollTop = position;\n          }\n        },\n        getURL() {\n          return window?.location?.href;\n        },\n        setURL(url) {\n          if (window?.location) {\n            window.location = url;\n          }\n        },\n        setHeight(height) {\n          iframe.current.style.height = height;\n        },\n        getIMSAccessToken() {\n          if (imsHack?.isSignedInUser()) {\n            return imsHack.getAccessToken();\n          }\n\n          return null;\n        },\n        getIMSProfile() {\n          if (imsHack?.isSignedInUser()) {\n            return imsHack.getProfile();\n          }\n\n          return null;\n        },\n        signIn() {\n          if (imsHack && !imsHack.isSignedInUser()) {\n            imsHack.signIn();\n          }\n        },\n        signOut() {\n          if (imsHack && imsHack.isSignedInUser()) {\n            imsHack.signOut();\n          }\n        },\n        getIMSClientId() {\n          if (imsHack) {\n            return imsHack.adobeIdData.client_id;\n          } else {\n            return null;\n          }\n        }\n      }\n    });\n\n    connection.promise.then((child) => {\n      if (iframe.current.clientHeight === 0) {\n        child.onHide();\n      } else {\n        child.onShow();\n      }\n      setChild(child);\n    });\n\n    // Notify that the connection is ready and the iframe src may be set\n    setConnectionReady(true);\n\n    return connection;\n  };\n\n  return (\n    <>\n      <iframe\n        title=\"Main content\"\n        ref={iframe}\n        src={connectionReady ? iframeSrc : ''}\n        css={css`\n          display: block;\n          height: ${height};\n          width: 100%;\n          border: none;\n        `}\n      />\n      <Footer />\n    </>\n  );\n};\n\nFrame.propTypes = {\n  src: PropTypes.string,\n  height: PropTypes.string,\n  location: PropTypes.object\n};\n\nexport default Frame;\n"],"names":["Resolution","ErrorCode","NativeErrorName","MessageType","NativeEventType","DEFAULT_PORT_BY_PROTOCOL","URL_REGEX","opaqueOriginSchemes","serializeError","_ref","name","message","stack","id","keyPathToSegments","keyPath","split","setAtKeyPath","subject","value","segments","reduce","prevSubject","key","idx","length","methods","prefix","flattenedMethods","Object","keys","forEach","push","join","segmentsToKeyPath","createKeyPath","assign","callSender","info","methodKeyPaths","destroyConnection","log","localName","local","remote","originForSending","originForReceiving","destroyed","concat","createMethodProxy","methodName","_len","arguments","args","Array","_key","iframeRemoved","closed","e","error","Error","code","ConnectionDestroyed","Promise","resolve","reject","generateId","handleMessageEvent","event","source","data","penpal","Reply","origin","replyMessage","removeEventListener","Message","returnValue","returnValueIsError","obj","deserializedError","deserializeError","resolution","Fulfilled","addEventListener","callMessage","Call","postMessage","api","deserializeMethods","serializedMethods","childOrigin","destructor","destroy","onDestroy","destroyCallReceiver","receiverMethodNames","window","createPromiseHandler","Rejected","err","DataCloneError","errorReplyMessage","apply","then","receiverMethodName","methodNames","destroyCallSender","options","iframe","timeout","debug","console","callbacks","callback","src","srcdoc","NoIframeSrc","validateIframeHasSrcOrSrcDoc","find","scheme","startsWith","location","document","regexResult","exec","protocol","hostname","port","portSuffix","getOriginFromSrc","handleSynMessage","synAckMessage","SynAck","handleSynMessageFactory","handleAckMessage","handleAckMessageFactory","promise","stopConnectionTimeout","timeoutId","undefined","setTimeout","ConnectionTimeout","clearTimeout","handleMessage","contentWindow","Syn","Ack","checkIframeInDocIntervalId","setInterval","isConnected","clearInterval","monitorIframeRemoval","height","useRef","ims","isLoadingIms","useContext","Context","imsHack","child","setChild","useState","connectionReady","setConnectionReady","useEffect","current","clientHeight","onHide","onShow","pathname","adobeIMS","connection","createConnection","iframeSrc","isExternalLink","withPrefix","connectToChild","URL","scrollTop","position","_document","scrollingElement","getURL","_window","_window$location","href","setURL","url","_window2","setHeight","style","getIMSAccessToken","_imsHack","isSignedInUser","getAccessToken","getIMSProfile","_imsHack2","getProfile","signIn","signOut","getIMSClientId","adobeIdData","client_id","___EmotionJSX","React","title","ref","css","Footer"],"sourceRoot":""}